# ██████╗████████╗ █████╗ ██████╗ ████████╗  ██████╗ ██████╗ ██╗███╗  ██╗████████╗
#██╔════╝╚══██╔══╝██╔══██╗██╔══██╗╚══██╔══╝  ██╔══██╗██╔══██╗██║████╗ ██║╚══██╔══╝
#╚█████╗    ██║   ███████║██████╔╝   ██║     ██████╔╝██████╔╝██║██╔██╗██║   ██║   
# ╚═══██╗   ██║   ██╔══██║██╔══██╗   ██║     ██╔═══╝ ██╔══██╗██║██║╚████║   ██║   
#██████╔╝   ██║   ██║  ██║██║  ██║   ██║     ██║     ██║  ██║██║██║ ╚███║   ██║   
#╚═════╝    ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝     ╚═╝     ╚═╝  ╚═╝╚═╝╚═╝  ╚══╝   ╚═╝ 
[gcode_macro START_PRINT]
gcode:
    {% set BED_TEMP = params.BED_TEMP|default(60)|float %}
    {% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}
    # Start bed heating
    M140 S{BED_TEMP}
    #Seta temperatura do extrusor e aguarda
    RESPOND MSG="Aguardando aquecimento do bico"
    M109 S{EXTRUDER_TEMP}
    
    # Use absolute coordinates
    G90
    # Reset the G-Code Z offset
    SET_GCODE_OFFSET Z=0.0
    # Home the printer
    G28
    # Wait for bed to reach temperature
    M190 S{BED_TEMP}
    #Executa nivelamento da mesa 
    BED_MESH_CALIBRATE PRINT_MIN={params.PRINT_MIN} PRINT_MAX={params.PRINT_MAX}
    # Log inicial com o valor atual da variável
    RESPOND MSG=" START_PRINT: [MMU BYPASS CHECK] Verificando tool atual: {printer.mmu.tool}"
    {% if printer.mmu.tool == -1 or printer.mmu.tool == -2 %}
        # Tool é -1 ou -2, executa movimento direto
        RESPOND MSG="START_PRINT: [MMU BYPASS CHECK] Tool é {printer.mmu.tool} Usando porta de Bypass - Executando movimento direto G1 X0 Y2.50 Z0.78 F2400"
        G1 X0 Y2.50 Z0.78 F2400
        RESPOND MSG="START_PRINT: [MMU BYPASS CHECK] Movimento direto concluído"
        MMU_TEST_CONFIG enable_clog_detection=0
        RESPOND MSG="START_PRINT: [MMU BYPASS CHECK] Desativando detecão de obstrução"
    {% else %}
        # Tool não é -1 nem -2, executa macro PURGA_PREUNLOAD
        RESPOND MSG="START_PRINT: [MMU BYPASS CHECK] Tool é {printer.mmu.tool} - Impressão sem Bypass"
    {% endif %}
    
    RESPOND MSG="START_PRINT: [MMU BYPASS CHECK] Verificação de BYPASS  finalizada"
    RESPOND TYPE=command MSG="START_PRINT: Perfil SKEW carregado no início da impressão"
    SKEW_PROFILE LOAD=skew_profile
    GET_CURRENT_SKEW

   

#███████╗███╗  ██╗██████╗   ██████╗ ██████╗ ██╗███╗  ██╗████████╗
#██╔════╝████╗ ██║██╔══██╗  ██╔══██╗██╔══██╗██║████╗ ██║╚══██╔══╝
#█████╗  ██╔██╗██║██║  ██║  ██████╔╝██████╔╝██║██╔██╗██║   ██║   
#██╔══╝  ██║╚████║██║  ██║  ██╔═══╝ ██╔══██╗██║██║╚████║   ██║   
#███████╗██║ ╚███║██████╔╝  ██║     ██║  ██║██║██║ ╚███║   ██║   
#╚══════╝╚═╝  ╚══╝╚═════╝   ╚═╝     ╚═╝  ╚═╝╚═╝╚═╝  ╚══╝   ╚═╝  
[gcode_macro END_PRINT]
gcode:
    # Turn off bed, extruder, and fan
    M140 S0
    M104 S0
    M106 S0
    # Move nozzle away from print while retracting
    G1 X0 Y0


    # Disable steppers
    M84
    RESPOND TYPE=command MSG="END_PRINT: Perfil SKEW descarregado após término da impressão"
    SET_SKEW CLEAR=1

#██╗      █████╗  █████╗ ██████╗   ███████╗██╗██╗      █████╗ ███╗   ███╗███████╗███╗  ██╗████████╗
#██║     ██╔══██╗██╔══██╗██╔══██╗  ██╔════╝██║██║     ██╔══██╗████╗ ████║██╔════╝████╗ ██║╚══██╔══╝
#██║     ██║  ██║███████║██║  ██║  █████╗  ██║██║     ███████║██╔████╔██║█████╗  ██╔██╗██║   ██║   
#██║     ██║  ██║██╔══██║██║  ██║  ██╔══╝  ██║██║     ██╔══██║██║╚██╔╝██║██╔══╝  ██║╚████║   ██║   
#███████╗╚█████╔╝██║  ██║██████╔╝  ██║     ██║███████╗██║  ██║██║ ╚═╝ ██║███████╗██║ ╚███║   ██║   
#╚══════╝ ╚════╝ ╚═╝  ╚═╝╚═════╝   ╚═╝     ╚═╝╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝╚══════╝╚═╝  ╚══╝   ╚═╝  
[gcode_macro LOAD_FILAMENT]
gcode:
    MMU_LOAD

#██╗   ██╗███╗  ██╗██╗      █████╗  █████╗ ██████╗   ███████╗██╗██╗      █████╗ ███╗   ███╗███████╗███╗  ██╗████████╗
#██║   ██║████╗ ██║██║     ██╔══██╗██╔══██╗██╔══██╗  ██╔════╝██║██║     ██╔══██╗████╗ ████║██╔════╝████╗ ██║╚══██╔══╝
#██║   ██║██╔██╗██║██║     ██║  ██║███████║██║  ██║  █████╗  ██║██║     ███████║██╔████╔██║█████╗  ██╔██╗██║   ██║   
#██║   ██║██║╚████║██║     ██║  ██║██╔══██║██║  ██║  ██╔══╝  ██║██║     ██╔══██║██║╚██╔╝██║██╔══╝  ██║╚████║   ██║   
#╚██████╔╝██║ ╚███║███████╗╚█████╔╝██║  ██║██████╔╝  ██║     ██║███████╗██║  ██║██║ ╚═╝ ██║███████╗██║ ╚███║   ██║   
# ╚═════╝ ╚═╝  ╚══╝╚══════╝ ╚════╝ ╚═╝  ╚═╝╚═════╝   ╚═╝     ╚═╝╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝╚══════╝╚═╝  ╚══╝   ╚═╝ 
[gcode_macro UNLOAD_FILAMENT]
gcode:
    MMU_UNLOAD

[gcode_macro PRE_UNLOAD]
gcode:
    RESPOND TYPE=command MSG="PRE_UNLOAD: Perfil SKEW descarregado antes da troca de filamento"
    SET_SKEW CLEAR=1


#███████╗██╗██╗      █████╗ ███╗   ███╗███████╗███╗  ██╗████████  ██████╗ ███████╗████████╗███████╗ █████╗ ████████╗
#██╔════╝██║██║     ██╔══██╗████╗ ████║██╔════╝████╗ ██║╚══██╔══  ██╔══██╗██╔════╝╚══██╔══╝██╔════╝██╔══██╗╚══██╔══╝
#█████╗  ██║██║     ███████║██╔████╔██║█████╗  ██╔██╗██║   ██║    ██║  ██║█████╗     ██║   █████╗  ██║  ╚═╝   ██║   
#██╔══╝  ██║██║     ██╔══██║██║╚██╔╝██║██╔══╝  ██║╚████║   ██║    ██║  ██║██╔══╝     ██║   ██╔══╝  ██║  ██╗   ██║   
#██║     ██║███████╗██║  ██║██║ ╚═╝ ██║███████╗██║ ╚███║   ██║    ██████╔╝███████╗   ██║   ███████╗╚█████╔╝   ██║   
#╚═╝     ╚═╝╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝╚══════╝╚═╝  ╚══╝   ╚═╝    ╚═════╝ ╚══════╝   ╚═╝   ╚══════╝ ╚════╝    ╚═╝   

[save_variables]
filename: ~/printer_data/config/mmu/mmu_vars.cfg

# Macro para obter filamento restante
[gcode_macro GET_FILAMENT_REMAINING]
description: Retorna o valor do filamento restante
gcode:
    {% set remaining = printer.save_variables.variables.mmu_state_filament_remaining|default(0) %}
    {action_respond_info("Filamento restante: %d mm" % remaining)}
    SET_GCODE_VARIABLE MACRO=GET_FILAMENT_REMAINING VARIABLE=value VALUE={remaining}

variable_value: 0

# Macro para obter a cor do filamento restante
[gcode_macro GET_REMAINING_COLOR]
description: Retorna a cor do filamento restante
gcode:
    {% set color = printer.save_variables.variables.mmu_state_filament_remaining_color|default('ffffff') %}
    {action_respond_info("Cor do filamento restante: %s" % color)}
    SET_GCODE_VARIABLE MACRO=GET_REMAINING_COLOR VARIABLE=value VALUE='"{color}"'

variable_value: "ffffff"

# Macro para obter a cor do filamento ativo
[gcode_macro GET_ACTIVE_COLOR]
description: Retorna a cor do filamento ativo do Happy Hare
gcode:
    {% if printer.mmu.active_filament %}
        {% set filament_color = printer.mmu.active_filament.color %}
        {action_respond_info("Cor do filamento ativo: %s" % filament_color)}
        SET_GCODE_VARIABLE MACRO=GET_ACTIVE_COLOR VARIABLE=value VALUE='"{filament_color}"'
    {% else %}
        {action_respond_info("Nenhum filamento ativo detectado")}
        SET_GCODE_VARIABLE MACRO=GET_ACTIVE_COLOR VARIABLE=value VALUE='"none"'
    {% endif %}

variable_value: "none"

# Macro para capturar dados do filamento ANTES do carregamento# Macro para capturar dados do filamento ANTES do carregamento
[gcode_macro PRE_LOAD]
description: >
  Captura dados do filamento restante e cor ANTES do carregamento.
  Esta macro deve ser executada ANTES de qualquer troca de filamento
  para permitir verificação inteligente de cor na PURGA_MECANICA.
gcode:
    #Temporario para solucionar bug
    #MMU_TEST_CONFIG sync_to_extruder=1 QUIET=1
    # Capturar cor do filamento restante
    {% set remaining_color = printer.save_variables.variables.mmu_state_filament_remaining_color|default('ffffff') %}
    
    # Capturar comprimento do filamento restante
    {% set remaining_length = printer.save_variables.variables.mmu_state_filament_remaining|default(0) %}
    
    # Capturar cor do filamento ativo atual
    {% set current_active_color = printer.mmu.active_filament.color %}
    
    # Salvar nas variáveis da macro PRE_LOAD
    SET_GCODE_VARIABLE MACRO=PRE_LOAD VARIABLE=saved_remaining_color VALUE='"{remaining_color}"'
    SET_GCODE_VARIABLE MACRO=PRE_LOAD VARIABLE=saved_remaining_length VALUE={remaining_length}
    SET_GCODE_VARIABLE MACRO=PRE_LOAD VARIABLE=saved_active_color VALUE='"{current_active_color}"'
    
    {action_respond_info("PRE_LOAD: Cor restante capturada: %s" % remaining_color)}
    {action_respond_info("PRE_LOAD: Comprimento restante capturado: %d mm" % remaining_length)}
    {action_respond_info("PRE_LOAD: Cor ativa capturada: %s" % current_active_color)}

# Variáveis para armazenar os dados capturados
variable_saved_remaining_color: "ffffff"
variable_saved_remaining_length: 0
variable_saved_active_color: "none"


#██████╗ ██╗   ██╗██████╗  ██████╗ ███████╗
#██╔══██╗██║   ██║██╔══██╗██╔════╝ ██╔════╝
#██████╔╝██║   ██║██████╔╝██║  ██╗ █████╗  
#██╔═══╝ ██║   ██║██╔══██╗██║  ╚██╗██╔══╝  
#██║     ╚██████╔╝██║  ██║╚██████╔╝███████╗
#╚═╝      ╚═════╝ ╚═╝  ╚═╝ ╚═════╝ ╚══════╝
[gcode_macro PURGA_MMU]
# ==========================================================
# MACRO: PURGA_MMU
# ==========================================================
# Descrição: Purga mecânica com servo/balde integrado e escova,
#            com ciclos curtos, wipe final e opção de retração.
#            Suporte a primeira purga com volume diferenciado.
#            NOVA FUNCIONALIDADE: Verificação inteligente de cor na primeira purga.
#            IMPORTANTE: Execute PRE_LOAD antes da troca de filamento!
#
# PARÂMETROS OPCIONAIS (passados via console):
# ----------------------------------------------------------
# VOLUME=<valor>          -> Volume de filamento a purgar em mm³
# TESTE=<0|1|2>           -> Modo de teste:
#                              0 = purga normal (extrusão + servo)
#                              1 = só movimentos (sem extrusão, sem servo)
#                              2 = movimentos + servo (sem extrusão)
# DEBUG=<0|1>             -> Imprime cálculos e posições no console
# RETRACT=<valor>         -> Retração em mm após purga (0 = sem retração)
#
# IMPORTANTE: Execute PRE_LOAD antes da primeira troca de filamento!
# ==========================================================
description: >
  Purga mecânica com servo/escova integrada, ciclos curtos no balde, wipe final e opção de retração.
  NOVA: Verificação inteligente de cor na primeira purga para evitar desperdício.
  IMPORTANTE: Execute PRE_LOAD antes da troca de filamento!
  
  PARÂMETROS:
  • VOLUME=<valor>    → Volume de filamento a purgar em mm³
  • TESTE=<0|1|2>     → Modo: 0=purga normal (extrusão+servo), 1=só movimentos, 2=movimentos+servo
  • DEBUG=<0|1>       → Imprime cálculos e posições no console (0=off, 1=on)
  • RETRACT=<valor>   → Retração em mm após purga (0=sem retração)
gcode:
    RESPOND TYPE=command MSG="PURGA_MMU: Perfil SKEW descarregado antes da purga"
    SET_SKEW CLEAR=1
    # Parâmetros de entrada
    {% set manual_volume = params.VOLUME|default(0)|float %}
    {% set teste_mode = params.TESTE|default(0)|int %}
    {% set debug = params.DEBUG|default(0)|int %}
    {% set manual_retract = params.RETRACT|default(-1)|float %}
    
    # ===== CONFIGURAÇÕES DA MACRO =====
    # (Edite estes valores para personalizar)
    {% set bucket_x = 122 %}                    # Centro X do balde 124
    {% set bucket_y = 333 %}                    # Centro Y do balde 333
    {% set bucket_spread = 15 %}                # Largura de distribuição no balde (mm)
    {% set brush_x = 122 %}                     # Centro X da escova 124
    {% set brush_y = 317 %}                     # Centro Y da escova 317
    {% set purge_z = 20 %}                      # Altura mínima Z
    {% set purge_feed = 400 %}                  # Velocidade de extrusão
    {% set filament_diameter = 1.75 %}          # Diâmetro do filamento
    {% set purge_cycles = 5 %}                  # Número de ciclos
    {% set default_retract = 12 %}              # Retração padrão
    {% set brush_strokes = 2 %}                 # Movimentos na escova
    {% set brush_amplitude = 10 %}              # Largura do movimento
    {% set wipe_offset = 15 %}                  # Deslocamento final
    {% set safe_x = 150 %}                      # Posição segura X
    {% set safe_y = 150 %}                      # Posição segura Y
    {% set first_purge_volume = 450 %}          # Volume para primeira purga (mm³)
    {% set same_color_margin = 3 %}           # Margem de 30% para mesma cor
    # =====================================
    
    # Usar valor manual de retração se fornecido
    {% set retract_after_purge = manual_retract if manual_retract >= 0 else default_retract %}
    
    # Obter número de trocas de ferramenta
    {% set num_toolchanges = printer.mmu.num_toolchanges|default(0)|int %}
    
    # ===== NOVA LÓGICA DE VERIFICAÇÃO DE COR =====
    # Determinar volume de purga com verificação inteligente de cor
    {% if manual_volume > 0 %}
        {% set purge_volume = manual_volume %}
        {% set volume_source = "manual" %}
    {% elif num_toolchanges == 0 %}
        # PRIMEIRA PURGA - VERIFICAR CORES USANDO DADOS SALVOS
        
        # Obter dados salvos pelo PRE_LOAD
        {% set saved_remaining_color = printer["gcode_macro PRE_LOAD"].saved_remaining_color|string|replace('"', '') %}
        {% set saved_remaining_length = printer["gcode_macro PRE_LOAD"].saved_remaining_length|float %}
        {% set saved_active_color = printer["gcode_macro PRE_LOAD"].saved_active_color|string|replace('"', '') %}
        
        {% if debug %}
            RESPOND TYPE=command MSG="PURGA_MMU: Cor restante (salva): '{saved_remaining_color}' | Comprimento restante (salvo): {saved_remaining_length}mm"
            RESPOND TYPE=command MSG="PURGA_MMU: Cor ativa (salva): '{saved_active_color}'"
        {% endif %}
        
        # Verificar se as cores são iguais (ignorando maiúsculas/minúsculas)
        {% if saved_remaining_color|lower == saved_active_color|lower and saved_remaining_color != "ffffff" and saved_active_color != "none" %}
            # MESMA COR - Usar filamento restante + 30%
            {% if saved_remaining_length > 0 %}
                {% set optimized_length = saved_remaining_length * same_color_margin %}
                {% set filament_area = 3.1416 * (filament_diameter/2)**2 %}
                {% set purge_volume = optimized_length * filament_area %}
                {% set volume_source = "mesma_cor_otimizada" %}
                
                RESPOND TYPE=command MSG="PURGA_MMU: *** MESMA COR DETECTADA *** Filamento restante: {saved_remaining_length|round(1)}mm"
                RESPOND TYPE=command MSG="PURGA_MMU: Cores: {saved_remaining_color} = {saved_active_color}"
                RESPOND TYPE=command MSG="PURGA_MMU: Volume otimizado: {purge_volume|round(1)}mm³ (economia de filamento!)"
            {% else %}
                # Se não conseguiu obter o comprimento restante, usar volume padrão
                {% set purge_volume = first_purge_volume %}
                {% set volume_source = "primeira_purga_fallback" %}
                RESPOND TYPE=command MSG="PURGA_MMU: Mesma cor detectada, mas sem dados de comprimento válidos. Usando volume padrão."
            {% endif %}
        {% else %}
            # COR DIFERENTE ou dados inválidos - Usar volume padrão da primeira purga
            {% set purge_volume = first_purge_volume %}
            {% set volume_source = "primeira_purga_cor_diferente" %}
            
            {% if saved_remaining_color == "ffffff" or saved_active_color == "none" %}
                RESPOND TYPE=command MSG="PURGA_MMU: *** PRIMEIRA PURGA *** Dados de cor indisponíveis. Volume padrão: {purge_volume|round(1)}mm³"
                RESPOND TYPE=command MSG="PURGA_MMU: DICA: Execute PRE_LOAD antes da troca para verificação de cor!"
            {% else %}
                RESPOND TYPE=command MSG="PURGA_MMU: *** PRIMEIRA PURGA *** Cores diferentes detectadas:"
                RESPOND TYPE=command MSG="PURGA_MMU: Restante: {saved_remaining_color} ≠ Ativa: {saved_active_color}"
                RESPOND TYPE=command MSG="PURGA_MMU: Volume padrão: {purge_volume|round(1)}mm³"
            {% endif %}
        {% endif %}
    {% else %}
        {% set purge_volume = printer.mmu.toolchange_purge_volume %}
        {% set volume_source = "normal" %}
    {% endif %}

    {% set filament_area = 3.1416 * (filament_diameter/2)**2 %}
    {% set purge_length = purge_volume / filament_area %}
    {% set cycle_length = (purge_length / purge_cycles) if purge_cycles|int > 0 else 0 %}

    # Mensagem informativa sobre o número de trocas de ferramenta
    {% if num_toolchanges == 0 %}
        RESPOND TYPE=command MSG="PURGA_MMU: *** PRIMEIRA PURGA *** - Trocas: {num_toolchanges} | Volume: {purge_volume|round(1)} mm³ | Fonte: {volume_source}"
    {% endif %}

    RESPOND TYPE=command MSG="PURGA_MMU: Purga: {purge_volume|round(1)} mm³ ({purge_length|round(1)} mm) | TESTE={teste_mode} | DEBUG={debug} | Fonte: {volume_source}"
    {% if debug %}
      RESPOND TYPE=command MSG="PURGA_MMU: Trocas de ferramenta: {num_toolchanges}"
      RESPOND TYPE=command MSG="PURGA_MMU: Centro balde: X{bucket_x} Y{bucket_y}"
      RESPOND TYPE=command MSG="PURGA_MMU: Centro escova: X{brush_x} Y{brush_y}"
      RESPOND TYPE=command MSG="PURGA_MMU: Ciclos de purga: {purge_cycles} | Por ciclo: {cycle_length|round(2)} mm"
      RESPOND TYPE=command MSG="PURGA_MMU: Retração após purga: {retract_after_purge} mm"
    {% endif %}

    SAVE_GCODE_STATE NAME=PURGA_MMU_STATE

    {% set current_z = printer.toolhead.position.z %}
    {% if current_z < purge_z %}
      G90
      G1 Z{purge_z} F3000
    {% endif %}

    # --- ABRE BANDEJA (pula se TESTE=1) ---
    {% if teste_mode != 1 %}
      PURGE_SERVO_OPEN
      G4 P500
    {% endif %}

    # --- PURGA NO BALDE ---
    G90
    MMU_SYNC_GEAR_MOTOR SYNC=1
    G1 X{bucket_x} Y{bucket_y} F7800
    {% if debug %} RESPOND TYPE=command MSG="PURGA_MMU: Na posição do balde" {% endif %}

    {% if teste_mode == 0 %}
      G91
      {% for i in range(purge_cycles|int) %}
        # Calcular posição X para distribuir filamento (de -spread/2 a +spread/2)
        {% set x_offset = (bucket_spread / (purge_cycles - 1)) * i - (bucket_spread / 2) if purge_cycles > 1 else 0 %}
        {% set target_x = bucket_x + x_offset %}
        
        # Mover para nova posição X antes de extruir
        G90
        G1 X{target_x} F7800
        {% if debug %} RESPOND TYPE=command MSG="PURGA_MMU: Ciclo {i+1}: X{target_x|round(1)}" {% endif %}
        
        # Extruir nesta posição
        G91
        G1 E{cycle_length|round(2)} F{purge_feed}
        G4 P200
      {% endfor %}
      G90
      
      # Voltar ao centro do balde para retração
      #G1 X{bucket_x} F7800
      
      {% if retract_after_purge|float > 0 %}
        G91
        G1 E-{retract_after_purge|float} F2400
        G90
        {% if debug %} RESPOND TYPE=command MSG="PURGA_MMU: Retração de {retract_after_purge} mm aplicada" {% endif %}
      {% endif %}
    {% endif %}

    # --- LIMPEZA NA ESCOVA ---
    G90
    G1 X{brush_x} Y{brush_y} F6000
    {% if debug %} RESPOND TYPE=command MSG="PURGA_MMU: Na posição da escova" {% endif %}

    {% for i in range(brush_strokes|int) %}
      G91
      G1 X{brush_amplitude} F3000
      G1 X-{2*brush_amplitude} F3000
      G1 X{brush_amplitude} F3000
      G90
    {% endfor %}

    # --- WIPE FINAL ---
    G90
    G1 X{brush_x + brush_amplitude} Y{brush_y} F3000
    G1 X{brush_x + brush_amplitude + wipe_offset} F3000

    # --- SAFE POSITION ---
    G1 X{safe_x} Y{safe_y} F7800

    # --- RECOLHE BANDEJA (pula se TESTE=1) ---
    {% if teste_mode != 1 %}
      PURGE_SERVO_CLOSE
      G4 P500
    {% endif %}

    RESTORE_GCODE_STATE NAME=PURGA_MMU_STATE
    RESPOND TYPE=command MSG="PURGA_MMU: Perfil SKEW carregado após a purga"
    SKEW_PROFILE LOAD=skew_profile

# █████╗ ██╗   ██╗████████╗████████╗██╗███╗  ██╗ ██████╗    ██████╗███████╗██████╗ ██╗   ██╗ █████╗ 
#██╔══██╗██║   ██║╚══██╔══╝╚══██╔══╝██║████╗ ██║██╔════╝   ██╔════╝██╔════╝██╔══██╗██║   ██║██╔══██╗
#██║  ╚═╝██║   ██║   ██║      ██║   ██║██╔██╗██║██║  ██╗   ╚█████╗ █████╗  ██████╔╝╚██╗ ██╔╝██║  ██║
#██║  ██╗██║   ██║   ██║      ██║   ██║██║╚████║██║  ╚██╗   ╚═══██╗██╔══╝  ██╔══██╗ ╚████╔╝ ██║  ██║
#╚█████╔╝╚██████╔╝   ██║      ██║   ██║██║ ╚███║╚██████╔╝  ██████╔╝███████╗██║  ██║  ╚██╔╝  ╚█████╔╝
# ╚════╝  ╚═════╝    ╚═╝      ╚═╝   ╚═╝╚═╝  ╚══╝ ╚═════╝   ╚═════╝ ╚══════╝╚═╝  ╚═╝   ╚═╝    ╚════╝ 


# Macro para abrir o servo de corte de filamento
[gcode_macro CUTTING_SERVO_OPEN]
gcode:
    _CUT_TIP_GANTRY_SERVO_DOWN

# Macro para fechar o servo de corte de filamento
[gcode_macro CUTTING_SERVO_CLOSE]
gcode:
    _CUT_TIP_GANTRY_SERVO_UP


[gcode_macro DUMP_VARIABLES]
description: >
    Isso exibe todas as variáveis atuais do Klipper no terminal de código G.
    Isso ajuda a encontrar variáveis de sistema do Klipper para uso em macros. É possível aplicar um filtro tanto por nome quanto por valor.
    Argumentos
        NAME (string) - Filtrar resultados com base no nome (mostrar apenas variáveis com nomes que contenham esta string)
        VALUE (string) - Filtrar resultados com base no valor (mostrar apenas valores que contenham esse valor)
        SHOW_CFG (número inteiro, 0-1) - Defina como 1 para incluir toda a configuração na saída. O padrão é 0 (configuração filtrada).
    Exemplos
        DUMP_VARIABLES: Retorna todas as variáveis (exceto ` printer['configfile'].configand` printer['configfile'].settings, pois elas contêm toda a configuração).
        DUMP_VARIABLES NAME=stepperRetorna todas as variáveis que contêm a string stepperem seus nomes.
        DUMP_VARIABLES VALUE=extruderRetorna todas as variáveis que contêm a string extruderem seu valor.
        DUMP_VARIABLES NAME=stepper VALUE=extruderRetorna todas as variávei que têm a string stepperem seu nome e a string extruderem seu valor.
        DUMP_VARIABLES SHOW_CFG=1Retorna todas as variáveis, incluindo a configuração.
gcode:
    {% set filter_name = params.NAME|default('')|string|lower %}
    {% set filter_value = params.VALUE|default('')|string|lower %}
    {% set show_cfg = params.SHOW_CFG|default(0)|int %}
    
    {% set out = [] %}

    {% for key1 in printer %}
        {% for key2 in printer[key1] %}
            {% if (show_cfg or not (key1|lower == 'configfile' and key2|lower in ['config', 'settings'])) and (filter_name in key1|lower or filter_name in key2|lower) and filter_value in printer[key1][key2]|string|lower %}
                {% set dummy = out.append("printer['%s'].%s = %s" % (key1, key2, printer[key1][key2])) %}
            {% endif %}
        {% else %}
            {% if filter_name in key1|lower and filter_value in printer[key1]|string|lower %}
                {% set dummy = out.append("printer['%s'] = %s" % (key1, printer[key1])) %}
            {% endif %}
        {% endfor %}
    {% endfor %}
    
    {action_respond_info(out|join("\n"))}



[gcode_macro GET_VARIABLE]
description: >
 Esta função retorna o valor e o tipo de uma única variável para o terminal de código G. 
 Chaves e índices podem ser encadeados para acessar dicionários e listas aninhados.
 Exemplos:
    GET_VARIABLE NAME=toolhead: Retorna o valor e o tipo da variável printer.toolhead.
    GET_VARIABLE NAME=bed_mesh.profiles.default.points.1.0: Retorna o valor e o tipo da variável printer.bed_mesh.profiles.default.points[1][0].
gcode:
    {% set names = (params.NAME).split('.')|list %}
    {% set join = (params.JOIN)|default(1)|int %}
    
    {% set _dummy0 = namespace( break = 0 ) %}
    {% set _dummy1 = namespace( out = printer[names|first] ) %}
    
    {% for name in names if _dummy0.break == 0 %}
        {% if loop.index > 1 %}
            {% if name in _dummy1.out %}
                {% set _dummy1.out = _dummy1.out[name] %}
            {% elif name[0] in '0123456789' and _dummy1.out is iterable and _dummy1.out is not string and _dummy1.out is not mapping and _dummy1.out|length > name[0]|int %}
                {% set _dummy1.out = _dummy1.out[name|int] %}
            {% else %}
                {% set _dummy0.break = loop.index0 %}
            {% endif %}
        {% endif %}
    {% endfor %}
    
    {% if _dummy1.out is boolean %}
        { action_respond_info('Type: boolean') }
    {% elif _dummy1.out is float %}
        { action_respond_info('Type: float') }
    {% elif _dummy1.out is integer %}
        { action_respond_info('Type: integer') }
    {% elif _dummy1.out is mapping %}
        { action_respond_info('Type: mapping') }
    {% elif _dummy1.out is string %}
        { action_respond_info('Type: string') }
    {% elif _dummy1.out is iterable %}
        { action_respond_info('Type: iterable') }
    {% elif _dummy1.out is none %}
        { action_respond_info('Type: none') }
    {% elif _dummy1.out is undefined %}
        { action_respond_info('Type: undefined') }
    {% elif _dummy1.out is callable %}
        { action_respond_info('Type: callable') }
    {% else %}
        { action_respond_info('Type: unknown') }
    {% endif %}
    
    {% if join and _dummy1.out is iterable and _dummy1.out is not string and _dummy1.out is not mapping %}
        { action_respond_info('%s' % _dummy1.out|join("\n")) }
    {% else %}
        { action_respond_info('%s' % _dummy1.out) }
    {% endif %}
    
    {% if _dummy0.break != 0 %}
        { action_respond_info('"printer.%s" does not contain "%s"!' % (names[0:_dummy0.break]|join('.'), names[_dummy0.break])) }
    {% endif %}